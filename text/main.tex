\section{Smart-контракты}
\label{section.main.smart}

В данной главе будет описываться строение и реализация смарт-контрактов.

\subsection{Структура NFT smart-контракта}
\label{section.main.smart.struct}
В данной подглаве будет описываться строение NFT smart-контракта, написанного на языке Rust. Вся логика соответствует описанному стандарту NEP-171\cite{nftstandart}.
\paragraph{NEAR SDK}
Введем основные функции, структуры, декараторы, которые используются при написании smart-контрактов. Для этого необходим фреймворк near-sdk\cite{nearsdkrs}.

Атрибуты:

\begin{listing}[H]
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
#[near_bindgen]                                                 /* генерирует smart-контракт, совместимый с блокчейном NEAR */
#[derive(BorshDeserialize, BorshSerialize)]                     /* запоминает состояние контракта */
#[derive(PanicOnDefault)]                                       /* не позволяет инициализировать контракт дефолтными значениями, нужен метод new с декоратором init */
#[payable]                                                      /* помечает метод, который может принимать депозит */
\end{minted}
\caption{Атрибуты NEAR SDK фреймворк}
\label{near.attributes}
\end{listing}

Структуры:

\begin{listing}[H]
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
LookupMap       /* Неитерируемый словарь, который хранит свои значения в боре */
UnorderedMap    /* Итерируемый словарь, который хранит свои значения в боре */
UnorderedSet    /* Итерируемое множество объектов, которые хранятся в боре */
LazyOption      /* Структура, которая лениво инициализируется */
\end{minted}
\caption{Структуры NEAR SDK фреймворк}
\label{near.structures}
\end{listing}

Функции:
\begin{listing}[H]
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
env::storage_byte_cost()            /* стоимость хранения одного байта */
env::attached_deposit()             /* внесенный депозит */
env::predecessor_account_id()       /* предыдущий аккаунт от которого прилетел cross-contract call или это мы сами, если мы первые в цепочке */
env::log_str()                      /* написать лог */
env::prepaid_gas()                  /* количество gas предоставленного для call другой функции */
\end{minted}
\caption{Функции NEAR SDK фреймворк}
\label{near.functions}
\end{listing}

\paragraph{Core Functionality}

Опишем основные структуры и функции\cite{corestandard}, которые используются в NFT контрактах.

\begin{listing}[H]
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
pub type TokenId = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub base_uri: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<Base64VecU8>,
}
\end{minted}
\caption{Метаданные NFT контракта}
\label{nftcontract.metadata}
\end{listing}

Структура контракта представляет из себя следующие поля:
\begin{enumerate}
\item spec - версия, является обязательным полем.
\item name - название контракта, является обязательным полем.
\item symbol - краткое название, является обязательным полем.
\item icon - иконка, которая будет отображаться вместе с контрактом (URL).
\item base\_uri - URL, который ведет на надежное централизованное хранилище данных в reference.
\item reference - URL на JSON с дополнительными данными (JSON должен располагаться в децентрализованном хранилище).
\item reference\_hash - SHA256 хэш от JSON на который ведет URL в поле reference.
\end{enumerate}

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>,
    pub description: Option<String>,
    pub media: Option<String>,
    pub media_hash: Option<Base64VecU8>,
    pub copies: Option<u64>,
    pub issued_at: Option<u64>,
    pub expires_at: Option<u64>,
    pub starts_at: Option<u64>,
    pub updated_at: Option<u64>,
    pub extra: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<Base64VecU8>,
}
\end{minted}
\caption{NFT контракт структура TokenMetadata}
\label{nftcontract.tokenmetadata}
\end{listing}

Структура метаданных токена (Листинг {\color{blue} \ref{nftcontract.tokenmetadata}}) состоит из следующих полей:
\begin{enumerate}

\item title - название NFT токена.
\item description - описание NFT токена.
\item media - ссылка на содержимое NFT токена, желательно, чтобы эта ссылка вела на децентрализованное хранилище.
\item media\_hash - хэш от содержимого NFT токена, на которое ведет поле media.
\item copies - количество копий NFT токена.
\item issued\_at - время, когда NFT токен был создан.
\item expires\_at - время, когда время жизни NFT токена истекает.
\item starts\_at - время, когда токен начал быть валидным.
\item extra - любые дополнительные данные.
\item reference - ссылка на json с дополнительной информацией о JSON.
\item reference\_hash - SHA256 хэш от содержимого на которое ведет ссылка в поле reference.

\end{enumerate}

\begin{listing}[H]
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    pub owner_id: AccountId,
    pub next_approval_id: u64,
    pub approved_account_ids: HashMap<AccountId, u64>,
    pub royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub metadata: TokenMetadata,
    pub approved_account_ids: HashMap<AccountId, u64>,
    pub royalty: HashMap<AccountId, u32>
}
\end{minted}
\caption{NFT контракт структура Token и JsonToken}
\label{nftcontract.tokenstructs}
\end{listing}

Структура NFT токена (Листинг {\color{blue} \ref{nftcontract.tokenstructs}}) представляет из себя 3 связанные структуры:
\begin{enumerate}
    \item TokenMetadata - метаданные токена, где каждое из полей является опциональным.
    \item Token - для каждого токена образуется связь:
    \begin{enumerate}
        \item owner\_id - аккаунт владельца токена.
        \item approved\_accounts\_ids - словарь из доверенных аккаунтов, где значения является счетчик версий.
        \item next\_approval\_id - текущая версия токена.
        \item royalty - доля других аккаунтов, на получение денег с продажи токена.
    \end{enumerate}
    \item JsonToken - endpoint структура, которая возвращается при работе с контрактом извне.
\end{enumerate}

Теперь опишем структуру класса контракта, в котором хранятся созданные токены:
\begin{listing}[H]
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub tokens_by_id: LookupMap<TokenId, Token>,
    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
    pub metadata: LazyOption<NFTContractMetadata>,
}
\end{minted}
\caption{NFT contract struct}
\label{nftcontract.struct}
\end{listing}

\begin{enumerate}
\item owner\_id - владелец контракта, которые задается единственный раз при инициализации.
\item metadata - метаданные контракта, которые задаются единственный раз при инициализации.
\item tokens\_per\_owner - позволяет по аккаунту получить все токены, которыми владеет.
\item tokens\_by\_id - позволяет по TokenId получить структуру Token описанную выше.
\item tokens\_metadata\_by\_id - позволяет по TokenId получить структуру TokenMetadata описанную выше.
\end{enumerate}

Следующая функция из core functionality без которой нельзя осуществить никакой продажи - создание или mint NFT токена. Функция nft\_mint принимает token\_id, метаданные, владельца и royalties (см. {\color{blue}\ref{section.main.smart.struct.royalties}}).
Так как это payable функция, то пользователь должен будет внести депозит для хранения информации о добавляемом токене. Лишний депозит вернется пользователю обратно.
Также в отличие от Paras мы не обязуем пользователя привязывать токен к конкретной коллекции чем с одной стороны дали больше свободы пользователю, а с другой стороны упростили реализацию.

Псевдокод создание токена описан в листинге {\color{blue}\ref{nftcontract.mint}}.

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
#[payable]
fn nft_mint(token_id, metadata, receiver_id, royalties) {
    /* Сохранить начальный storage_usage*/
    start_storage_usage = env::storage_usage();

    /* Распаковать и положить royalties */
    royalty = AcceptRoyalties(royalties);

    /* Создать токен */
    token = CreateToken(metadata, royalties);

    /* Проверить, что такого token_id не существует */
    assert(!Exist(token_id));

    /* Добавить токен в необходимые структуры */
    contract.tokens_by_id.Insert(token_id, token);
    contract.token_metadata_by_id.Insert(token_id, metadata);
    add_token_to_owner(token.owner_id, token_id);

    /* Вернуть неиспользованный депозит */
    refund(env::storage_usage() - start_storage_usage);
}
\end{minted}
\caption{NFT token mint}
\label{nftcontract.mint}
\end{listing}

Каждый пользователь может запросить на просмотр любой NFT токен с помощью view функции nft\_token, указав в параметрах token\_id.
В качестве результата пользователь получит JsonToken структуру, описанную выше или None, если такого токена не существует (Листинг {\color{blue}\ref{nftcontract.entoken}}).

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
fn nft_token(token_id) -> Option<JsonToken> {
    if !Exist(token_id) {
        return None;
    } else {
        return ConstructJsonToken(token_id);
    }
}
\end{minted}
\caption{NFT nft\_token}
\label{nftcontract.entoken}
\end{listing}

Последние функции из core functionality отвечают за передачу nft токена:
\begin{enumerate}
\item nft\_transfer - отправить токен другому аккаунту.
\item nft\_transfer\_call - отправить токен другому аккаунту для выполнения какой-то услуги, то есть должна будет выполниться какая-то дополнительная логика на другом smart-контракте.
\item nft\_on\_transfer - дополнительная логика, которая должна исполниться в другом контракте после nft\_transfer\_call.
\item nft\_resolve\_transfer - функция, которая определяет нужно ли возвращать токен обратно или нет после nft\_on\_transfer.
\end{enumerate}
С первой функция все ясно, она просто отправляет токен, а со второй лучше привести иллюстрацию:

\begin{figure}[H]
	\centering
	\includegraphics[height=70mm]{fig/temp.png}
	\caption{nft\_transfer\_call}
\end{figure}

Смоделируем пример, где мы хотим отправить из contract\_1 свой токен в другой контракт contract\_2 и выполнить в нем дополнительную сервисную логику(например contract\_2 это контракт маркетплейса, который должен будет выставить что-то на продажу).
Тогда сервисная логика должна будет реализована в nft\_on\_transfer. Вызывать ее должен будет nft\_transfer\_call и завершать всю эту цепочку должна будет функция nft\_resolve\_transfer.
Псевдокод функций описан в листинге {\color{blue}\ref{nftcontract.transfer1}}.

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
fn nft_on_transfer(sender_id, previous_owner_id, token_id, msg) -> Promise;

#[payable]
fn nft_transfer_call(receiver_id, token_id, approval_id, msg) -> PromiseOrValue<bool> {

    /* Сохраняем отправителя и копию токена до отправки */
    sender_id = env::predecessor_account_id();
    previous_token = own_contract.internal_transfer(sender_id, receiver_id, token_id, approval_id);

    /* Если отправитель не владелец, значит мы ему доверили наш токен, подробнее в главе approval managements */
    authorized_id = None;
    if sender_id != previous_token.owner_id {
        authorized_id = sender_id;
    }

    /* Вызываем nft_on_transfer на другом контракте, потом nft_resolve_transfer на своем */
    return reciever_contract::nft_on_transfer(
        sender_id,
        previous_token.owner_id,
        token_id,
        msg,
        receiver_id,
    ).then(
        own_contract::nft_resolve_transfer(
            authorized_id,
            previous_token.owner_id,
            receiver_id,
            token_id,
            previous_token.approved_account_ids,
        )
    )
}

#[private]
fn nft_resolve_transfer(
    authorized_id,
    owner_id, receiver_id,
    token_id, approved_account_ids,
) -> bool {

    /* Передача произошла успешно */
    if IsSuccesfull() {
        return true
    }

    /* Иначе возвращаем токен обратно владельцу */
    own_contract.internal_remove_token_from_owner(receiver_id, token_id);
    own_contract.internal_add_token_to_owner(owner_id, token_id);
    token.owner_id = owner_id;
    refund_approved_account_ids(receiver_id, token.approved_account_ids);
    token.approved_account_ids = approved_account_ids;
    own_contract.tokens_by_id.insert(token_id, token);

    return false
}
\end{minted}
\caption{NFT контракт transfer}
\label{nftcontract.transfer1}
\end{listing}

\paragraph{Enumeration}
Для удобного взаимодействия с контрактом, необходимо добавить больше view функций с pagination для просмотра NFT токенов\cite{enumstandard}:
\begin{enumerate}
\item nft\_total\_supply - получить общее количество существующих токенов.
\item nft\_tokens - получить существующие токены, используя pagination.
\item nft\_supply\_for\_owner - получить общее количество существующих токенов для конкретного аккаунта.
\item nft\_token\_for\_owner - получить существующие токены для конкретного аккаунта, используя pagination.
\end{enumerate}

Псевдокод вышеописанных функций можно найти в листинге {\color{blue}\ref{nftcontract.transfer}}.

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
pub fn nft_total_supply() -> U128 {
    return length(own_contract.token_metadata_by_id)
}

pub fn nft_tokens(from_index, limit) -> Vec<JsonToken> {
    return own_contract.token_metadata_by_id.keys()
        .skip(from_index)
        .take(limit)
        .map(|token_id| self.nft_token(token_id))
        .collect()
}

pub fn nft_supply_for_owner(account_id) -> U128 {
    if Exist(account_id) {
        return length(own_contract.tokens_per_owner.get(account_id))
    } else {
        return 0
    }
}

pub fn nft_tokens_for_owner(
    account_id,
    from_index,
    limit
) -> Vec<JsonToken> {
    if Exist(account_id) {
        return tokens.iter()
            .skip(from_index)
            .take(limit)
            .map(|token_id| self.nft_token(token_id))
            .collect()
    } else {
        return vec![];
    }
}
\end{minted}
\caption{NFT контракт enumeration}
\label{nftcontract.transfer}
\end{listing}

\paragraph{Approval Management}
Необходимо добавить функционал передачи своего токена другим аккаунтом от своего имени\cite{approvalstandard}. Для этого будет хранить список доверенных аккаунтов (approved\_account\_ids).
Также структура токена хранит next\_approval\_id, который изначально равен 0 и увеличивается на единицу при каждом новом добавленном доверенном аккаунте.

Рассмотрим пример, где account\_1 решил создать токен, тогда у него будет следующая структура, которая описана в листинге {\color{blue}\ref{nftcontract.approval1}}.
\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
Token: {
    owner_id: account_1
    approved_accounts_ids: {}
    next_approval_id: 0
}
\end{minted}
\caption{NFT контракт approval management}
\label{nftcontract.approval1}
\end{listing}

Если он решит добавить account\_2, account\_3, как доверенные тогда структура примет вид как в листинге {\color{blue}\ref{nftcontract.approval2}}.
\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
Token: {
    owner_id: account_1
    approved_accounts_ids: {
        account_2: 0,
        account_3: 1
    }
    next_approval_id: 2
}
\end{minted}
\caption{NFT контракт approval management}
\label{nftcontract.approval2}
\end{listing}

Счетчик next\_approval\_id  необходим, чтобы не случилось случая, когда новый владелец токена решил добавить доверенный аккаунт, который был до этого. Такие случаи могут испортить всю логику на других smart-контрактах.
Подробнее краевые случаи описаны в стандарте\cite{approvalstandard}.

Approval Management не добавляет новых внешних view функций или payable функций, а просто вносит некоторую дополнительную логику проверки в существующие функции из секции Core Functionality.

\paragraph{Royalties}
\label{section.main.smart.struct.royalties}

Последнее чего требует стандарт - распределение прибыли от продажи NFT или от любой другой логики, которая будет возвращать NEAR среди нескольких аккаунтов в зависимости от долей\cite{royaltystandard}.
Для этого у нас есть поле royalty в структуре Token, которая отображает пары в соответствующие доли. Сумма всех долей должна быть равна 10.000.

Также добавятся две новые функции:
\begin{enumerate}
\item nft\_payout - получить распределение баланса в зависимости от долей для конкретного token\_id.
\item nft\_transfer\_payout - совершить перевод токена и вернуть распределение баланса от долей.
\end{enumerate}
Псевдокод данных функций можно найти в листингах {\color{blue}\ref{nftcontract.approval3}} и {\color{blue}\ref{nftcontract.approval4}}.
\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
fn nft_payout(token_id, balance) -> Payout {
    /* Проверить, что токен существует */
    assert(ExistToken(token_id))

    /* Достать структуру токен */
    token = own_contract.tokens_by_id.get(token_id);
    result = PayoutConstruct();

    /* Посчитать доли других аккаунтов */
    current_sum = 0;
    for (key, value) in Iter(token.royalty) {
        if key == token.owner_id {
            continue;
        }
        result.payout.insert(
            key, CalcPayout(value, balance)
        );
        current_sum += value;
    }
    /* Посчитать свою долю */
    result.payout.insert(token.owner_id, CalcPayout(10000 - current_sum, balance));
    return result
}
\end{minted}
\caption{NFT контракт nft\_payout}
\label{nftcontract.approval3}
\end{listing}

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
#[payable]
fn nft_transfer_payout(
    receiver_id, token_id,
    approval_id, balance,
) -> Payout {
    /* Отправить токен */
    sender_id = env::predecessor_account_id();
    prev_token = own_contract.internal_transfer(sender_id, receiver_id, token_id, approval_id);

    result = PayoutConstruct();

    /* Посчитать доли других аккаунтов */
    current_sum = 0;
    for (key, value) in Iter(prev_token.royalty) {
        if key == prev_token.owner_id {
            continue;
        }
        result.payout.insert(key, CalcPayout(value, balance));
        current_sum += value;
    }
    /* Посчитать свою долю */
    result.payout.insert(prev_token.owner_id, CalcPayout(10000 - current_sum, balance));
    return result
}
\end{minted}
\caption{NFT контракт nft\_transfer\_payout}
\label{nftcontract.approval4}
\end{listing}

\subsection{Структура маркетплейс smart-контракта}

В данной главе будет описано строение маркетплейс smart-контракта. Контракт маркетплейса уже не подчиняется никакому стандарту и может быть реализован разными способами.
Мы придерживались архитектуры, которая была описана у Paras({\color{blue}\ref{section.theory.paras}}), то есть один маркетплейс smart-контракт с которым будут взаимодействовать пользователи.

\paragraph{Core functionality}

Начнем с функций, которые должны быть доступны пользователю:
\begin{enumerate}
    \item Выставить NFT токен на продажу.
    \item Обновить цену своего выставленного на продажу NFT токена.
    \item Убрать с продажи свой выставленный до этого NFT токен.
    \item Получить список выставленных на продажу NFT токенов.
    \item Купить выставленный на продажу NFT токен.
\end{enumerate}

Заметим, что на маркетплейс должны уметь выставлять токены нескольких NFT контрактов, потому что все они стандартизированны.
То есть пользователи могут покупать/продавать токены абсолютно разных NFT контрактов.

\begin{figure}[h!]
	\centering
	\includegraphics[height=70mm]{fig/marketplace.png}
	\caption{Маркетплейс контракт core functionality}
\end{figure}

Структура маркетплейс контракта описана в листинге {\color{blue}\ref{marketplacecontract.struct}}.

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}

/* Так как выставить токен могут с разных контрактов, удобно будет соединить их в одной строке */
/* ContractAndTokenId = contract ID + DELIMITER + token ID */
pub type ContractAndTokenId = String;
/* Цена токенов будет в YoctoNear */
pub type SalePriceInYoctoNear = U128;
pub type TokenId = String;

/* Структура NFT токена выставленного на продажу */
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    /* Владелец NFT токена */
    pub owner_id: AccountId,

    /* Значение этого поля обоснован в главе Approval Management */
    pub approval_id: u64,

    /* nft_contract_id с которого был выставлен NFT токен */
    pub nft_contract_id: String,

    /* Идентификатор выставленного токена */
    pub token_id: String,

    /* Цена */
    pub sale_conditions: SalePriceInYoctoNear,
}

/* Структура контракта */
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /* Владелец контракта */
    pub owner_id: AccountId,

    /* Выставленные на продажу токены по ContractAndTokenId */
    pub sales: UnorderedMap<ContractAndTokenId, Sale>,

    /* Выставленные на продажу ContractAndTokenId по конкретному аккаунту */
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,

    /* Выставленные на продажу токены по конкретному аккаунту */
    pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<TokenId>>,

    /* Внесенная сумма на хранение nft токена */
    /* Смысл данной структуры будет обоснован позже */
    pub storage_deposits: LookupMap<AccountId, Balance>,
}
\end{minted}
\caption{Marketplace contract struct}
\label{marketplacecontract.struct}
\end{listing}

Когда пользователь хочет выставить на продажу NFT токен, он должен вызвать nft\_approve у своего NFT контракта, чтобы добавить аккаунт маркетплейса в доверенные аккаунты, тогда на контракте маркетплейса вызовется метод nft\_on\_approve, который добавит токен на продажу.
В результате, когда другой пользователь захочет купить токен, то маркетплейс сможет легко перевести его новому владельцу, потому он является доверенным аккаунтом для продаваемого токена.

На иллюстрации будет приведен пример, где пользователь выставляет на продажу два токена с двух разных NFT контрактов на одном маркетплейс контракте.

\begin{figure}[H]
	\centering
	\includegraphics[height=70mm]{fig/sell.png}
	\caption{Выставление на продажу в маркетплейс контракте}
\end{figure}

Псевдокод вышеописанного функционала можно увидеть в листинге {\color{blue}\ref{marketplacecontract.onapprove}}.

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
fn nft_on_approve(token_id, owner_id, approval_id, sale_price) {
    /* NFT контракт с которого был вызвана продажа */
    nft_contract_id = env::predecessor_account_id();

    /* Аккаунт пользователя, который подписал контракт */
    signer_id = env::signer_account_id();

    assert(owner_id == signer_id)

    /* Считаем сколько нужно на хранилище и сколько внесено */
    paid_storage = own_contract.storage_deposits.getPaidStorage(signer_id);
    required_storage = CalcRequiredStorage();
    assert(paid_storage > required_storage);

    /* Добавляем покупку в необходимые структуры */
    contract_and_token_id = nft_contract_id + '.' + token_id;
    own_contract.sales.InsertNewSale(
        contract_and_token_id, owner_id, approval_id, nft_contract_id, token_id, sale_price
    );

    own_contract.by_owner_id.InsertNewSale(
        contract_and_token_id, owner_id, approval_id, nft_contract_id, token_id, sale_price
    );

    own_contract.by_nft_contract_id.InsertNewSale(
        owner_id, approval_id, nft_contract_id, token_id, sale_price
    );
}
\end{minted}
\caption{Маркетплейс контракт nft\_on\_approve}
\label{marketplacecontract.onapprove}
\end{listing}

Так как мы делаем cross-contract call между двумя контрактами, тогда определить необходимые средства на хранения продаваемого NFT токена выглядит проблематичным.
Поэтому пользователь должен будет сам покупать хранилище и сам его освобождать, когда его токены продались и место освободилось. Именно для этого необходимо поле storage\_deposits в контракте.
Для внесения near под хранение используется функция storage\_deposit, а для вывода near за неиспользуемое место storage\_withdraw. Логика их кажется тривиальной, поэтому псевдокод приводиться не будет.

Изменение цены и отмена продажи, тоже выглядят достаточно тривиальными, функционал можно увидеть в коротком псевдокоде (Листинг {\color{blue}\ref{marketplacecontract.update}}).

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
#[payable]
pub fn remove_sale(nft_contract_id, token_id) {
    /* Проверим, что владелец токена пытается его убрать с продажи */
    assert (own_contract.sales.OwnerByToken(token_id) == env::precessor_account_id());

    /* Удаляем продажу из структур контракта */
    contract_and_token_id = nft_contract_id + '.' + token_id;
    own_contract.sales.RemoveByToken(token_id);
    own_contract.by_owner_id.RemoveByContractAndToken(owner_id, contract_and_token_id);
    own_contract.by_nft_contract_id.RemoveByContractAndToken(contract_and_token_id, token_id);
}

#[payable]
pub fn update_price(nft_contract_id, token_id, price) {
    /* Проверим, что владелец токена пытается его убрать с продажи */
    assert (self.sales.OwnerByToken(token_id) == env::precessor_account_id());

    /* Обновим цену продажи в структурах контракта */
    contract_and_token_id = nft_contract_id + '.' + token_id;
    own_contract.sales.UpdateByToken(token_id, price);
}
\end{minted}
\caption{Маркетплейс контракт изменение цены/отмена продажи}
\label{marketplacecontract.update}
\end{listing}

Покупка осуществляется следующим образом: пользователь дергает nft\_offer команду у маркетплейс контракта, тот в свою очередь вызывает nft\_transfer\_payout на NFT контракте, а потом завершает или отменяет покупку используя resolve\_purchase.
Функция resolve\_purchase при удачной покупке разделит сумму продажи относительно долей royalties. Данные величины нам возвращает функция nft\_transfer\_payout.

Схема покупки выглядит следующим образом (рис. {\color{blue}\ref{marketplacecontract.buypng}}), а с псевдокодом функций покупки можно ознакомиться в Листинге {\color{blue}\ref{marketplacecontract.buy}}.

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
#[payable]
pub fn offer(nft_contract_id, token_id) {
    /* Смотрим сколько пользователь внес депозита */
    deposit = env::attached_deposit();

    contract_token_id: String = contract_id + '.' + token_id;

    /* Получаем структуру продажи для token_id из нужного NFT контракта */
    offer_sale = own_contract.sales.get(contract_token_id);
    buyer_id = env::predecessor_account_id();

    /* Проверяем, что внесенный депозит больше цены и что покупатель не является владельцем */
    assert(offer_sale.owner_id != buyer_id);
    assert(deposit >= offer_sale.sale_conditions);

    own_contract.process_purchase(contract_id, token_id, deposit,buyer_id);
}

#[private]
pub fn process_purchase(nft_contract_id, token_id, price, buyer_id) -> Promise {
    /* Удаляем структуру продажи из соответствующих структур */
    purchased_sale = own_contract.internal_remove_sale(nft_contract_id, token_id);

    /* Вызываем nft_transfer_payout на NFT smart-контракте и завершаем покупку в resolve_purchase */
    nft_contract::nft_transfer_payout(
        buyer_id,
        token_id,
        purchased_sale.approval_id,
        price
    ).then(own_contract::resolve_purchase(
        buyer_id,
        price
    ))
}

#[private]
pub fn resolve_purchase(
    buyer_id,
    price,
) -> U128 {
    /* Если операция nft_transfer_payout на контракте NFT была выполнена успешно */
    if IsSuccess() {
        /* Получаем payout структуру из nft_transfer_payout */
        payout = PromisResult();

        /* Отправляем каждому royalti аккаунту соответствующую долю */
        for (receiver_id, amount) in payout {
            Transfer(receiver_id, amount);
        }
        return price;
    } else {
        return None;
    }
}
\end{minted}
\caption{Маркетплейс контракт покупка токена}
\label{marketplacecontract.buy}
\end{listing}

\begin{figure}[h]
	\centering
	\includegraphics[height=70mm]{fig/buy.png}
	\caption{Покупка токена}
    \label{marketplacecontract.buypng}
\end{figure}

\paragraph{Enumeration}

Для того чтобы удобно взаимодействовать с маркетплейс контрактом были добавлены несколько view функций, которые позволяют выгружать продаваемые NFT.
\begin{enumerate}
\item get\_supply\_sales - получить суммарное количество выставленных токенов.
\item get\_supply\_by\_owner\_id - получить суммарное количество выставленных токенов за определенным пользователем.
\item get\_supply\_by\_nft\_contract\_id - получить суммарное количество выставленных токенов за определенным NFT контрактом.
\item get\_sales\_by\_nft\_contract\_id - получить выставленные на продажу токены за определенным NFT контрактом, используя pagination.
\item get\_sales\_by\_owner\_id - получить выставленные на продажу токены за определенным пользователем, используя pagination.
\item get\_sale - получить определенный продаваемый токен.
\end{enumerate}

Псевдокод данных функций описан в листинге {\color{blue}\ref{marketplacecontract.enumeration}}.

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{rust}
pub fn get_supply_sales() -> u64 {
    return length(own_contract.sales);
}

pub fn get_supply_by_owner_id(account_id) -> u64 {
    owner_id = own_contract.by_owner_id.get(account_id);
    return length(owner_id);
}

pub fn get_sales_by_owner_id(account_id, from_index, limit) -> Vec<Sale> {
    sales = owner_contract.by_owner_id.get(account_id);

    sales.iter()
        .skip(from_index)
        .take(limit)
        .map(|token_id| owner_contract.sales.get(token_id))
        .collect()
}

pub fn get_supply_by_nft_contract_id(nft_contract_id) -> u64 {
    nft_contract_id = own_contract.by_nft_contract_id.get(nft_contract_id);
    return length(nft_contract_id);
}

pub fn get_sales_by_nft_contract_id(nft_contract_id, from_index, limit) -> Vec<Sale> {
    let sales = own_contract.by_nft_contract_id.get(nft_contract_id);

    sales.iter()
        .skip(from_index)
        .take(limit)
        .map(|token_id| own_contract.sales.get(nft_contract_id, '.', token_id))
        .collect()
}

pub fn get_sale(nft_contract_token) -> Option<Sale> {
    own_contract.sales.get(nft_contract_token)
}
\end{minted}
\caption{Маркетплейс контракт enumeration}
\label{marketplacecontract.enumeration}
\end{listing}

\section{Discord-бот}
\label{section.main.bot}

\subsection{Взаимодействие с блокчейнами}

В данной главе описано ядровое устройство discord-бота: описание работы near-api-js и его переписывание под устройство Discord, устройство метаданных NFT-токена, работа с децентрализованным распределенным хранилищем.

\paragraph{Аккаунты и access keys в NEAR}
Для понимания взаимодействия требуются минимальные знания об аккаунтах и access keys.

Аккаунты в NEAR\cite{nearaccounts} устроены так, что они имеют человеко-читаемый ID в отличие от большинства других блокчейнов, где обычно используется некоторый hash (Рисунок {\color{blue} \ref{fig.eth_near_cmp}}). Длина логина от 2 до 64 символов и содержит в конце суффикс обозначающий сеть блокчейна. Аккаунт может создавать подаккаунты, которые по своему функционалу ничем не отличаются от обычного аккаунта. Данные подаккаунты решают проблему развертывания контрактов: на один аккаунт можно развернуть только один smart-контракт, id аккаунта и будет значить, какой smart-контракт требуется.

\begin{definition}
    В NEAR, как и во всех блокчейнах есть несколько сетей: mainnet, testnet и так далее. Mainnet - главная (продакшн) сеть. Testnet используется для тестирования сервисов.
\end{definition}

Каждый аккаунт имеет создавать множество, которые в NEAR называются access keys. Существует два типа access keys: FullAccess и FunctionCall. Первый дает полный доступ, второй вид ключа уникален и дает разрешения только на подписание функций контрактов. В нашем сервисе не будет использоваться FullAccess access key из-за ненадобности.

\begin{figure}
    \centering
    \includegraphics[height=60mm]{fig/eth_near_cmp.png}
    \caption{Сравнение аккаунтов Ethereum и NEAR}
    \label{fig.eth_near_cmp}
\end{figure}

\paragraph{Авторизация в NEAR Wallet}

Авторизация в NEAR Wallet играет роль связывания аккаунта кошелька и пользователя, то есть фактически нам говорит, что у этого пользователя есть этот аккаунт. Наверное, стоит отметить, что, если пользователь авторизовался в NEAR Wallet на нашем сервисе, то от его лица можно вызывать методы контракта, на котором была подписана транзакция(пока не закончатся GAS, которые были указаны при подписании транзакции), к которым не нужно вложение депозита. Данный функционал нам не потребуется, так как у нас либо <<view operations>> в контрактах, либо <<payable change operations>>.

На маркетплейсах в виде сайта вся авторизация происходит на client-side стороне: создается пара ключей (access key) - публичный и секретный; секретный ключ сохраняется в local storage браузера; подписывается транзакция и в последствии этот ключ будет использован сайтом, для подтверждения авторизации (Рисунок {\color{blue} \ref{fig.nearauth.a}}). Сценарий авторизации в discord-бот различается, ведь ключ должен храниться на стороне сервера (Рисунок {\color{blue} \ref{fig.nearauth.b}}). Для этого были необходимо реализовать KeyStore, который взаимодействует с какой-нибудь базой данных на стороне сервера. На роль базы данных было принято использовать Redis. Был написан KeyStore, который взаимодействует с Redis и функционал, который возвращает URL, а не перенаправляет пользователя. При любом взаимодействии с ботом, проверяется авторизован ли пользователь, если он не авторизован, то ему предлагается кнопка с URL на подписание транзакции авторизации.

\begin{figure}
	\centering
    \subfloat[Авторизация в NEAR Wallet в near-api-js]{
        \label{fig.nearauth.a}
        \includegraphics[height=60mm]{fig/auth1.png}
    }
    \subfloat[Авторизация в NEAR Wallet в discord-боте]{
        \label{fig.nearauth.b}
        \includegraphics[height=60mm]{fig/auth2.png}
    }
    \caption{}
\end{figure}

\begin{definition}
    Storage --- интерфейс веб API, который позволяет добавлять, изменять, удалять элементы данных, которые представляются в виде ключа и значения\cite{webapistorage}. В веб API есть два объекта, которые используют интерфейс storage: session storage, local storage\cite{webapilocalstorage}. Session storage хранит данные до закрытия браузера, когда как данные в local storage не имеют ограничения по времени и могу быть удалены только намерено.
\end{definition}

\begin{definition}
    KeyStore\cite{nearclasskeystore} --- это класс, который хранит ключи, для подписей транзакций. Их 4 вида: BrowserLocalStorageKeyStore, InMemoryKeyStore, MergeKeyStore, UnencryptedFileSystemKeyStore. BrowserLocalStorageKeyStore пользуется локальным хранилищем браузера для записи, изменения, просмотра значений по ключу. InMemoryKeyStore хранит все в оперативной памяти, используется для тестирования. MergeKeyStore используется для объединения множества KeyStore. UnencryptedFileSystemKeyStore хранит все на диске в виде JSON файла, используется в near cli\cite{nearcli}.
\end{definition}

\paragraph{Вызовы методов у контрактов}

Вызовы методов у smart-контрактов --- это то, чем бот занимается большую часть времени. Как и в случае авторизации, на меркетплейсах в виде сайте подписывание транзакций происходит на client-side стороне (Рисунок {\color{blue} \ref{fig.neartr.a}}): проверка существования access key в local storage браузера, при существовании и еще нескольких условиях идет подписание транзакции без участия пользователя, в ином случае создается URL по которому пользователь подписывает транзакцию. В случае discord-бота (Рисунок {\color{blue} \ref{fig.neartr.b}}) просто выброшена та часть, которую возможно исполнить на client-side стороне и проверка на access key, из-за ненадобности, так как у нас только <<payable change operations>>.

near-api-js не предоставляет хороших оберток для подписания транзакций, в которых несколько Action и Transaction. В нашем случае такие сценарии нужны при отмене продажи NFT и покупки NFT. В случае выставлении на продажу требовалось вызывать методы в таком порядке: <<storage\_deposit>> у контракта маркетплейса для вложения депозита хранения, <<nft\_approve>> у контракта NFT для утверждения маркетплейса в NFT контракте и <<storage\_withdraw>> у контракта маркетплейса для возвращения неиспользуемых NEAR для хранения. В случае отмены продажи: <<offer>> и <<storage\_withdraw>> у контракта маркетплейса. Были написаны данные обертки.

\begin{definition}
    Есть несколько видов Action: CreateAccount, DeployContract, FunctionCall, Transfer, Stake, AddKey, DeleteKey, DeleteAccount. Из этого списка discord-бот использует только FunctionCall, который нужен для вызова методов у smart-контракта. FunctionCall образуется из названия метода, аргументов метода, вносимого депозита и вносимых GAS. Transaction это набор Action, и название контракта, то есть в одном Transaction можно подписывать только методы одного smart-контракта. При подписании транзакции может быть несколько Transaction, что нам позволяет подписывать за раз исполнение разных методов на разных smart-контрактах.
\end{definition}

\begin{figure}
    \centering
    \subfloat[Подпись транзакций в NEAR Wallet в near-api-js]{
        \label{fig.neartr.a}
        \includegraphics[height=53mm]{fig/transaction1.png}
    }
    \subfloat[Подпись транзакций в NEAR Wallet в discord-боте]{
        \label{fig.neartr.b}
        \includegraphics[height=53mm]{fig/transaction2.png}
    }
    \caption{}
\end{figure}

\paragraph{Структура получаемого NFT и его метаданных}
\label{section.main.bot.struct}
На данный момент, при создании NFT, в структуре (Листинг {\color{blue}\ref{lst.nftstructure}}) используются следующие поля: <<token\_id>>, <<owner\_id>>, <<royalty>>, <<metadata.title>>, <<metadata.media>>, <<metadata.reference>>. <<metadata.description>> не используется, все описание NFT хранится в метаданных в децентрализованном хранилище в целях экономии оплаты за хранение . В <<metadata.media>>, <<metadata.reference>> хранятся полные URL до медиа-файла и метаданных. В ближайшее время, планируется хранить только CID и только в поле media, так как медиа-файл и метаданные хранятся в одной директории, то для их определения достаточно одного CID (см. {\color{blue} \ref{section.main.bot.storage}}). ID токена при создании формируется следующим образом: ID NEAR аккаунта, который минтит NFT, и текущее время. Такая структура формирования ID токена позволяет искоренить все коллизии.

Структура метаданных (Листинг {\color{blue}\ref{lst.nftmetadata}}) полностью аналогично структуре метаданных в Paras, так как эта структура оправдана своей функциональностью. Только в отличие от Paras нет полей: <<collection>>, <<collection\_id>>, <<blurhash>>, <<mime\_type>>. <<collection>>, <<collection\_id>> нет, потому что на данный момент мы не поддерживаем коллекции NFT. <<mime\_type>>, <<blurhash>> из-за ненадобности.

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{js}
{
    token_id: 'chopik.testnet.1652636744470',
    owner_id: 'chopik.testnet',
    approved_account_ids: { 'papamsmarket.pojaleesh.testnet': 2 },
    royalty: { 'chopik.testnet': 10000 },
    metadata: {
        title: 'City',
        description: null,
        media: 'https://bafybeiahhurffoxjubs42l7bl3jjc5zk5vrafiijcxkhex2ukjm3zsbbti.ipfs.dweb.link/f',
        media_hash: null,
        copies: null,
        issued_at: null,
        expires_at: null,
        starts_at: null,
        updated_at: null,
        extra: null,
        reference: 'https://bafybeiahhurffoxjubs42l7bl3jjc5zk5vrafiijcxkhex2ukjm3zsbbti.ipfs.dweb.link/m',
        reference_hash: null
    }
}
\end{minted}
\caption{Структура получаемого NFT}
\label{lst.nftstructure}
\end{listing}

\begin{listing}
\begin{minted}[breaklines,fontsize=\scriptsize]{json}
{
    "description":"Cool city",
    "creator_id":"chopik.testnet",
    "attributes":[
        {"trait_type":"Time","value":"Night"},
        {"trait_type":"Color","value":"Blue"}
    ]
}
\end{minted}
\caption{Структура метаданных NFT в децентрализованном хранилище}
\label{lst.nftmetadata}
\end{listing}

\paragraph{Децентрализованное хранилище данных}
\label{section.main.bot.storage}

Обычно для хранения метаданных и медиа-объекта используется другой блокчейн специализированный под хранение. Связанно это с тем, что при развертывании smart-контракта пользователь платит в NEAR за хранение байт, которые хранит контракт, используя механизм, который называется storage staking. На основе storage stacking есть и атаки на smart-контракты, например <<million cheap data additions>> - злоумышленник добавляет огромное количество бесполезных данных при вызове методов, из-за этого в наших контрактах данное обложение в контрактах оплачивает пользователь, которому хочется минимизировать свои растраты на операции. Из-за этого лучше стратегий для хранения объемных файлов(в основном таковыми являются медиа-файлы) это хранить данные в off-chain. Популярным решением является IPFS, при котором любой набор данных представляется удобным адресом - CID. В роли сервиса предоставляющего хранилище был выбран NFT.Storage\cite{nftstorage} --- бесплатное децентрализованное хранилище NFT на IPFS\cite{ipfs} и Filecoin\cite{filecoin}. NFT.Storage предоставляет HTTP API для взаимодействия с хранилищем и обертку на Javascript.

\begin{remark}
    Цена на storage staking устанавливается сетью блокчейна, на данный момент это 1 NEAR за 100 КБ.
\end{remark}

\begin{definition}
    IPFS(InterPlanetary File System) - это протокол распределенной системы обмена файлов. При добавлении файла в IPFS, он делится на маленькие куски, криптографически хэшируется и отдается уникальный фингерпринтр, который называется CID(Content identifier) \cite{ipfs}.
\end{definition}

\begin{remark}
    Для того, чтобы построить стимулирующий слой для сохранения данных в IPFS существует Filecoin. Filecoin - это децентрализованное сетевое хранилище. Filecoin и IPFS - это два разных протокола, взаимодополняющие друг друга. Когда как IPFS позволяет пользователям хранить, запрашивать и передавать друг другу данные, в то время, как Filecoin предназначен для обеспечения системы постоянного хранения.
\end{remark}

\begin{remark}
    Изначально использовался сервис web3storage\cite{web3storage} для хранения, но он отличился медленной загрузкой, получением файлов, из-за чего появилась необходимость в смене на NFT.Storage.
\end{remark}

\subsection{Пользовательский интерфейс}

У пользователя, есть несколько мест откуда он может запускать команды бота: slash-команды (Рисунок {\color{blue} \ref{fig.slashcommands}}), контекстные меню по пользователю (Рисунок {\color{blue} \ref{fig.contextmenu}}) и сами профиля пользователей (Рисунок {\color{blue} \ref{fig.profile}}, Рисунок {\color{blue} \ref{fig.anotherprofile}}). Со своего профиля и с помощью slash-команд, все взаимодействия идут в отношении себя, когда как, при выборе профиля и использовании на нем функционала из контекстного меню операции совершаются в отношении этого пользователя.


\begin{figure}
    \centering
    \subfloat[Slash-команды бота]{
        \label{fig.slashcommands}
        \includegraphics[height=60mm]{fig/slash_commands.png}
    }\\
    \subfloat[Контекстные меню бота]{
        \label{fig.contextmenu}
        \includegraphics[height=60mm]{fig/context_menu.png}
    }
    \subfloat[Свой профиль пользователя]{
        \label{fig.profile}
        \includegraphics[height=60mm]{fig/profile.png}
    }
    \caption{Точки входа пользователя}
\end{figure}

Авторизация пользователя происходит через соответствующую slash-команду (Рисунок {\color{blue} \ref{fig.authbtn1}}) или при взаимодействии бота в отношении своего профиля, если пользователь не авторизован (Рисунок {\color{blue} \ref{fig.authbtn2}}).

\begin{figure}
    \centering
    \subfloat[Намереная авторизация]{
        \label{fig.authbtn1}
        \includegraphics[height=30mm]{fig/authbtn1.png}
    }
    \subfloat[Предложение об авторизации]{
        \label{fig.authbtn2}
        \includegraphics[height=30mm]{fig/authbtn2.png}
    }
    \caption{Авторизация пользователя}
\end{figure}

С помощью контекстных меню (Рисунок {\color{blue} \ref{fig.contextmenu}}), можно взаимодействовать с другими пользователями: мы можем получить профиль пользователя (Рисунок {\color{blue} \ref{fig.anotherprofile}}), его список NFT, его список продаваемых NFT (Рисунок {\color{blue} \ref{fig.nftonsaleuser}}).

\begin{remark}
    Если в контекстном меню взаимодействовать с собой, то эффект будет такой-же как от slash-команд, то есть фактически мы можем не использовать slash-команды вообще и взаимодействовать только через GUI (Graphical User Interface, Графический Пользовательский Интерфейс).
\end{remark}

\begin{figure}
    \centering
    \subfloat[Чужой профиль пользователя]{
        \label{fig.anotherprofile}
        \includegraphics[height=50mm]{fig/anotherprofile.png}
    }
    \subfloat[Взаимодействие с пользователем, если он не авторизован]{
        \label{fig.anotherprofileerror}
        \includegraphics[height=25mm]{fig/anotherprofileerror.png}
    }
    \caption{Взаимодействия с другими пользователями}
\end{figure}

При взаимодействии с пользователем мы можем купить у него NFT, если таковые имеются (Рисунок {\color{blue} \ref{fig.nftonsaleuser}}). В своем общем списке NFT, в своем списке продаваемых NFT или в общем списке продаваемых NFT (Рисунок {\color{blue} \ref{fig.cancelsalenftforsale}}) можно отменить продажу или сменить цену.

\begin{figure}
    \centering
    \subfloat[Список NFT на маркеплейсе]{
        \label{fig.buynftmarket}
        \includegraphics[height=60mm]{fig/buynftmarket.png}
    }
    \subfloat[Список продаваемых NFT у пользователя]{
        \label{fig.nftonsaleuser}
        \includegraphics[height=60mm]{fig/nftonsaleuser.png}
    }
    \subfloat[Подтверждение покупки]{
        \label{fig.buyconfirm}
        \includegraphics[height=60mm]{fig/buyconfirm.png}
    }
    \caption{Покупка NFT}
\end{figure}

\begin{figure}
    \centering
    \subfloat[Свой общий список NFT]{
        \label{fig.mynftlistcansale}
        \includegraphics[height=60mm]{fig/mynftlistcansale.png}
    }
    \subfloat[Указание цены, при продаже]{
        \label{fig.salemodal}
        \includegraphics[height=45mm]{fig/salemodal.png}
    }
    \subfloat[Подтверждение продажи]{
        \label{fig.saleconfirm}
        \includegraphics[height=60mm]{fig/saleconfirm.png}
    }
    \caption{Выставление NFT на продажу}
\end{figure}

\begin{figure}
    \centering
    \subfloat[Интерфейс продажи: свой список продаваемых NFT, общий список продаваемых NFT, свой общий список NFT]{
        \label{fig.cancelsalenftforsale}
        \includegraphics[height=60mm]{fig/mynftonsale.png}
    }
    \subfloat[Указание цены, при ее смене]{
        \label{fig.modalsale}
        \includegraphics[height=45mm]{fig/modalsale.png}
    }
    \subfloat[Подтверждение отмены продажи]{
        \label{fig.cancelsaleconfirm}
        \includegraphics[height=60mm]{fig/cancelsaleconfirm.png}
    }
    \caption{Отмена продажи и смена цены NFT}
\end{figure}

\begin{figure}
    \centering
    \subfloat[Сообщение о переходе в личные сообщения]{
        \label{fig.createnftdm}
        \includegraphics[height=20mm]{fig/createnftdm.png}
    }\\
    \subfloat[Конструктор NFT]{
        \label{fig.createnftconstructor}
        \includegraphics[height=60mm]{fig/createnftconstructor.png}
    }
    \subfloat[Законченное NFT]{
        \label{fig.createnftconstructordone}
        \includegraphics[height=60mm]{fig/createnftconstructordone.png}
    }
    \subfloat[Подтверждение минта]{
        \label{fig.createnftconstructorconfirm}
        \includegraphics[height=60mm]{fig/createnftconstructorconfirm.png}
    }
    \caption{Минт NFT}
    \label{fig.mintnft}
\end{figure}

Cо своего профиля (Рисунок {\color{blue} \ref{fig.profile}}) или с помощью slash-команды <</create\_nft>> можно запустить процесс создания NFT (Рисунок {\color{blue} \ref{fig.mintnft}}), он переводит пользователя в личные сообщение, так как от пользователя нужен будет медиа-объект, для загрузки которого, пока что нет функционала не через сообщения. NFT собирается в виде конструктора - NFT строится при добавлении нового элемента, для текстовых заполнений используются модалы, когда как для загрузки медиа-объекта, бот отправляет сообщение, в котором говорит, что пользователь должен ответить на это сообщение сообщением с медиа-объектом (если пользователь отвечает сообщением без медиа-файла, то выведется сообщение с ошибкой, на которое нужно будет ответить, чтобы загрузить медиа-файл).

\begin{remark}
    Визуальный вид списка NFT (Рисунок {\color{blue} \ref{fig.cancelsalenftforsale}}, Рисунок {\color{blue} \ref{fig.mynftlistcansale}}) меняется от их количества: если NFT меньше 7, то не будет кнопок <<+7>>, <<-7>>, которые будут подгружать следующие/предыдущие 7 NFT. Это сделано для того, чтобы в один момент не подгружать все NFT с блокчейна.

\end{remark}

\subsection{Развертывание бота}
	Чтобы развернуть наш проект в интернете используется Alibaba cloud ecs (Elastic Compute Service). Для этого используется проксирование с помощью nginx (Рисунок {\color{blue} \ref{fig.nginxganservice}}).
	\begin{figure}
		\centering
		\includegraphics[height=40mm]{fig/nginxganservice.png}
		\caption{Схема развертывания бота}
        \label{fig.nginxganservice}
	\end{figure}

\section{Генеративно-состязательная сеть}
\label{section.generative_adversial_network}

Данная глава описывает ход работы над созданием генеративно-состязательной сети.

\subsection{Тренировочные данные}

Очевидно, что стиль генерируемых изображений полностью зависит от набора данных, на котором обучается ваша модель. Общими размышлениями мы пришли к мнению, что стоит выбрать два набора данных для обучения: CryptoPunks и Anime Faces.

В качестве тренировочных данных для генерации криптопанков была использована вся коллекция из 10000 уникальных аватаров\cite{cryptopunks_dataset}.


Главным нюансом является размер изображений - он очень мал (24x24 пикселя). Конечно небольшой размер дает преимущества в скорости обучения модели, однако нам хочется генерировать более крупные и качественные изображения.
Обычный встроенный в библиотеку opencv resize очень сильно ухудшает качество самого изображения. Для решения данной проблемы я использовал предобученную модель EDSR\cite{EDSR}.

\begin{definition}
    EDSR (enhanced deep super-resolution network) - разновидность моделей машинного обучения, предназначенная для увеличения размера изображения с минимальной потерей качества самого изображения.
\end{definition}

Изначально в основе архитектуры использовался коэффициент масштабирования равный 2. Далее уже веса предобученной модели использовались для обучения с коэффициентами 3 и 4.

Ниже приведен наглядный пример сравнения качества увелечения размера изображения {\color{blue} \ref{fig.EDSR_difference}}.
\begin{figure}
    \centering
    \includegraphics[height=50mm]{fig/EDSR_difference.png}
    \caption{EDSR upscaled image}
    \label{fig.EDSR_difference}
\end{figure}
Слева находится оригинальное изображение, в центре увеличенное с помощью модели EDSR-x4, справа изображение увелечинное с помощью opencv.resize

Используя вышеописанные махинации с изображениями, получаем датасет внутри которого размер одного экземпляра составляет 256x256 пикселей.

\subsection{Свёрточные генеративно-состязательные сети}

\begin{definition}
    Свёрточные генеративно-состязательные сети (Deep Convolutional Generative Adverserial Networks, DCGAN) - это класс сверточных нейронных сетей, который является популярным представителем генеративных моделей\cite{dcgan}.
\end{definition}

Для начала рассмотрим общую схему обучения генеративно-состязательной модели {\color{blue} \ref{fig.GAN_fit_scheme}}.
\begin{figure}
    \centering
    \includegraphics[height=100mm]{fig/GAN_fit_scheme.png}
    \caption{Процесс обучения GAN}
    \label{fig.GAN_fit_scheme}
\end{figure}
На вход генератору подается вектор случайного шума, в свою очередь генератор генерирует изображение. Это сгенерированное изображение подается в дискриминатор наряду с потоком изображений, взятых из фактического набора данных. В то же время дискриминатор, принимая как реальные, так и поддельные изображения, возвращает числа либо 0, либо 1, причем 1 представляет собой подлинное изображение и 0 представляет фальшивое.

Теперь вернемся к нашему DCGAN, в отличие от остальных генеративно-состязательных моделей в основе нашего генератора и дискриминатора должны быть сверточные слои.

\paragraph{Генератор}

Рассмотрим подробнее схему генератора {\color{blue} \ref{fig.generator_scheme_DCGAN}}.
\begin{figure}
    \centering
    \includegraphics[height=60mm]{fig/generator_scheme_DCGAN.png}
    \caption{}
    \label{fig.generator_scheme_DCGAN}
\end{figure}
В качестве входных данных нейросети подается вектор шума ($z$) и благодаря транспорированным свёрточным слоям (transposed convolution layers) создаёт фальшивое изображение. В каждом слое увеличиваем размер изображения вдвое, при этом уменьшаем размер фильтра в два раза. Вкаждома слое функция активации ReLU используется в генераторе, за исключением выходного уровня, который использует функцию Tanh.
Также применяем пакетую нормализацию (Batch Normalization), которая стабилизирует обучение путем нормализации входных данных для каждой единицы, чтобы иметь нулевое среднее значение и дисперсию единицы. Это помогает справиться с проблемами обучения, возникающими из-за плохой инициализации, и помогает градиентному потоку в более глубоких моделях.

\paragraph{Дискриминатор}

Рассмотрим подробнее схему дискриминатора {\color{blue} \ref{fig.discriminator_scheme_DCGAN}}.
\begin{figure}
    \centering
    \includegraphics[height=60mm]{fig/discriminator_scheme_DCGAN.png}
    \caption{}
    \label{fig.discriminator_scheme_DCGAN}
\end{figure}
В случае с дискриминатором мы поступим иначе, будем удваивать размер фильтра на каждом сверточном слое. Также применяем batch normalization и в качестве функции активации берем LeakyReLU.

\subsection{StyleGAN}
Для начала стоит рассказать о том, что такое StyleGAN. StyleGAN - это тип генеративно-состязательной сети. В нем используется альтернативная архитектура генератора, заимствованная из статьи о передачи стиля. \cite{styletransfer}

В традиционном подходе к обучению GAN, z-вектор передается в качестве входных данных генератору, проходя через входной уровень cети прямого распространения (Рисунок {\color{blue} \ref{fig.stylegan_scheme}}(а)). В новом генераторе же отходят от этой схемы, полностью опуская входной слой и вместо этого начиная с изученной константы (Рисунок {\color{blue} \ref{fig.stylegan_scheme}}(b)). Далее с помощью нелинейной функции $f : \mathcal{Z} \rightarrow \mathcal{W}$ сопоставляем входные данные со скрытым пространством $W$. Функция отображения представляет собой полностью связанную нелинейную функцию или 8-слойный MLP.Изученное отображение стиля W линейно преобразуется в множество векторов “A” для слоя AdaIN, используя стили $y = (y_s, y_b)$, которые управляют адаптивной нормализацией объекта (AdaIN) операции после каждого уровня свертки сети синтеза $g$. Операция AdaIN определяется как
\begin{equation}
    \operatorname{AdaIN}\left(\mathbf{x}_{i}, \mathbf{y}\right)=\mathbf{y}_{s, i} \frac{\mathbf{x}_{i}-\mu\left(\mathbf{x}_{i}\right)}{\sigma\left(\mathbf{x}_{i}\right)}+\mathbf{y}_{b, i}
\end{equation}
где каждая карта признаков (feature maps) объекта $x_i$ нормализуется отдельно, а затем масштабируется и смещается с использованием соответствующих скалярных компонентов из стиля $y$. Таким образом, размерность $y$ в два раза превышает количество карт признаков на этом слое. Наконец, генератору предоставляют прямое средство для генерации стохастической детализации, вводя явные шумовые входные данные.Векторы случайного шума $B$ - это одноканальные изображения, состоящие из некоррелированного гауссова шума, и далее выделенное изображение шума передается на каждый уровень сети синтеза $g$, как показано на рисунке {\color{blue} \ref{fig.stylegan_scheme}}(b)\cite{StyleGAN}.

\begin{definition}
    $z$-вектор - это не что иное, как вектор, содержащий случайные значения из гауссова (нормального) распределения.
\end{definition}
\begin{definition}
    $\mathcal{Z}$-пространство - это пространство всех z-векторов.
\end{definition}
\begin{definition}
    $w$-вектор - это так называемый <<вектор стиля>> нашего изображения.
\end{definition}
\begin{definition}
    $\mathcal{W}$-пространство - это пространство всех w-векторов. Оно содержит ключ к управлению различными атрибутами/особенностями изображения. Это связано с тем, что W-пространство распутано, что означает, что каждое из 512 измерений кодирует уникальную информацию об изображении.
\end{definition}
\begin{definition}
    Карта признаков (feature map) - объединение нейронов, которые используют одни и те же веса.
\end{definition}

Вы можете задаться вопросом, почему сопоставление $z$ с $\mathcal{W}$ перед подачей его в генератор помогает повысить производительность. Это происходит потому, что он распутывает латентное пространство $\mathcal{W}$ и пространство изображений. Потому что скрытое пространство $\mathcal{W}$ и пространство изображений непрерывны, и генератор должен обеспечить правдоподобное изображение для каждого скрытого вектора. Но при нелинейном отображении от $z$ к $\mathcal{W}$, $\mathcal{W}$ не всегда должна быть фиксированной формой, и, таким образом, генератор испытывает меньшую нагрузку от размещения изображений в скрытом пространстве.

Новая архитектура генератора StyleGAN приводит к автоматизированному, неконтролируемому разделению атрибутов высокого уровня (например, позы и идентичности при обучении на человеческих лицах) и стохастическим изменениям в генерируемых изображениях (например, веснушки, волосы), а также обеспечивает интуитивное управление синтезом в зависимости от масштаба. Новый генератор улучшает современное состояние с точки зрения традиционных показателей качества распределения, приводит к явно лучшим свойствам интерполяции, а также лучше выявляет скрытые факторы вариации\cite{StyleGAN}.

\paragraph{Трюк с усечением в $\mathcal{W}$}

Рассмотрим распределение обучающих данных, видно, что области с низкой плотностью представлены плохо и, следовательно, генератору, вероятно, будет трудно обучаться. Это серьезная открытая проблема во всех методах генеративного моделирования. Однако известно, что рисование скрытых векторов из усеченного [42, 5] или иным образом сокращенного [34] пространства выборки имеет тенденцию улучшать среднее качество изображения, хотя при этом теряется некоторое количество вариаций.
Мы можем следовать аналогичной стратегии. Для начала мы вычислим центр масс $\mathcal{W}$ как $\overline{\mathbf{w}}=\mathbb{E}_{\mathbf{z} \sim P(\mathbf{z})}[f(\mathbf{z})]$
Затем мы можем масштабировать отклонение заданного $w$ от центра $\mathbf{w}^{\prime}=\overline{\mathbf{w}}+\psi(\mathbf{w}-\overline{\mathbf{w}})$, где $\psi < 1$.
\begin{figure}
    \centering
    \includegraphics[height=100mm]{fig/stylegan_scheme.png}
    \caption{}
    \label{fig.stylegan_scheme}
\end{figure}


\subsection{StyleGAN 2}
StyleGAN2 --- это генеративная состязательная сеть, основанная на StyleGAN с несколькими улучшениями. Во-первых, адаптивная нормализация объекта переделана и заменена методом нормализации, называемым демодуляцией веса. Во-вторых, вводится улучшенная схема обучения при постепенном увеличении, которая достигает той же цели - обучение начинается с фокусировки на изображениях с низким разрешением, а затем постепенно смещает фокус на все более высокие разрешения - без изменения топологии сети во время обучения. Кроме того, предлагаются новые типы регуляризации, такие как ленивая регуляризация и регуляризация длины пути.

Во многих изображениях, сгенерированных StyleGAN,  были замечены характерные визуальные артефакты. Было определено две причины этих артефактов и описаны изменения в архитектуре и методах обучения, которые их устраняют. Во-первых, исследуя происхождение распространенных артефактов, похожих на большие двоичные объекты, было обнаруженно, что генератор создает их, чтобы обойти недостаток дизайна в своей архитектуре. Во-вторых, был проведен анализ артефактов, связанных с прогрессивным ростом\cite{progressive_growing_of_gans}, который был очень успешным в стабилизации обучения GAN с высоким разрешением. По итогу был предложен альтернативный дизайн, который достигает той же цели — обучение начинается с фокусировки на изображениях с низким разрешением, а затем постепенно смещает фокус на все более высокие разрешения - без изменения топологии сети во время обучения. Этот новый дизайн также позволяет нам судить об эффективном разрешении сгенерированных изображений, которое оказывается ниже, чем ожидалось, что мотивирует увеличение производительности.\cite{StyleGAN2}

\begin{definition}
    Визуальные артефакты (также артефакты) - это аномалии, проявляющиеся во время визуального представления, например, в цифровой графике и других формах изображения, особенно в фотографии и микроскопии.
\end{definition}

\paragraph{Изменение нормализации, используемой генератором}.

\begin{figure}
    \centering
    \includegraphics[height=75mm]{fig/stylegan2_scheme.png}
    \caption{}
    \label{fig.stylegan2_scheme}
\end{figure}
Перепроектируем архитектуру сети синтеза $g$ StyleGAN (Рисунок {\color{blue} \ref{fig.stylegan2_scheme}}). (a) оригинальный стиль, где A обозначает изученный
аффинное преобразование из $\mathcal{W}$, которое создает стиль, а $B$ - это операция широковещательной передачи шума. (b) Та же схема с полной детализацией. Здесь мы разбили AdaIN на явную нормализацию с последующей модуляцией, обе из которых работают со средним значением и стандартным отклонением для каждой карты объектов. Также аннотировали изученные веса (w), смещения (b) и постоянный ввод (c), а также перерисовали серые прямоугольники так, чтобы для каждого блока был активен один стиль. Функция активации (негерметичный ReLU) всегда применяется сразу после добавления смещения. (c) Мы вносим несколько изменений в исходную архитектуру, которые обоснованы в основном тексте. Мы удаляем некоторые избыточные операции в начале, перемещаем добавление b и B за пределы активной области стиля и корректируем только стандартное отклонение для каждой карты объектов. (d) Пересмотренная архитектура позволяет нам заменить нормализацию экземпляра операцией “демодуляции”, которую мы применяем к весам, связанным с каждым уровнем свертки\cite{StyleGAN2}.

\paragraph{Пересмотрение прогрессивного роста}

Ключевая проблема заключается в том, что прогрессивно растущий генератор, по-видимому, сильно предпочитает расположение деталей. Мы считаем, что проблема заключается в том, что при прогрессивном росте каждое разрешение на мгновение служит выходным разрешением, заставляя его генерировать максимальные частотные детали, что затем приводит к тому, что обученная сеть имеет чрезмерно высокие частоты в промежуточных слоях, что ставит под угрозу инвариантность сдвига\cite{shift_invariant_networks}.

\begin{figure}
    \centering
    \includegraphics[height=100mm]{fig/stylegan2_generator.png}
    \caption{}
    \label{fig.stylegan2_generator}
\end{figure}

На рисунке {\color{blue} \ref{fig.stylegan2_generator}}(а) показан MSG-GAN \cite{MSG_GAN}, который соединяет соответствующие разрешения генератора и дискриминатора, используя несколько соединений с пропуском. На рисунке {\color{blue} \ref{fig.stylegan2_generator}}(b) эта конструкция упрощается путем увеличения выборки и суммирования вкладов выходных сигналов RGB, соответствующих различным разрешениям. В дискриминаторе аналогичным образом предоставляется изображение с пониженной дискретизацией каждому блоку разрешения дискриминатора. Также используется билинейную фильтрацию во всех операциях увеличения и уменьшения дискретизации. На рисунке {\color{blue} \ref{fig.stylegan2_generator}}(с) далее модифицируется конструкция, чтобы использовать остаточные соединения\cite{StyleGAN2}.

\subsection{Ход обучения моделей}

Используя предобработанные обучающие данные было обучено несколько моделей: DCGAN и StyleGAN 2.

\paragraph{Обучение с помощью DCGAN}

//TODO

\paragraph{Обучение с помощью StyleGAN 2}

Учитывая ограничения в мощностях для обучения моделей на основе StyleGAN 2, было принято решение использовать для обучения, где это возможно, уже предобученную модель. Для датасета с криптопанками не удалось найти предобученную модель, однако для датасета Anime Faces такая возможность предоставилась. Модель была обучена в течение 2 недель (около 24,664 итераций) на 4 графических процессорах Nvidia 2080ti со скоростью 35-70с на 1 тыс. изображений. Как результат качество генерируемых изображений для второго набора обучающих данных получилось лучше.
Примеры генерируемых изображений {\color{blue} \ref{fig.anime_girls_stylegan2}}, {\color{blue} \ref{fig.cryptopunks_images_stylegan2}}.

\begin{figure}
    \centering
    \includegraphics[height=50mm, width=.3\textwidth]{fig/anime_girl_seed0025.png}\hfill
    \includegraphics[height=50mm, width=.3\textwidth]{fig/anime_girl_seed0090.png}\hfill
    \includegraphics[height=50mm, width=.3\textwidth]{fig/anime_girl_seed0100.png}
    \caption{Anime Faces}
    \label{fig.anime_girls_stylegan2}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[height=50mm, width=.3\textwidth]{fig/cryptopunk_seed0085.png}\hfill
    \includegraphics[height=50mm, width=.3\textwidth]{fig/cryptopunk_seed0090.png}\hfill
    \includegraphics[height=50mm, width=.3\textwidth]{fig/cryptopunk_seed0265.png}
    \caption{CryptoPunks}
    \label{fig.cryptopunks_images_stylegan2}
\end{figure}

\section{Сервис с генеративно-состязательной сетью}
\label{section.ganservice}
  В данной главе будет описываться сервис для создания NFT с помощью генеративно-состязательной сети и описание его контракта.
\subsection{Устройство сервиса}

	Сервис представляет собой http-сервис, которому на вход подается GET-запрос от discord-бота и он на своей стороне генерирует картинку, характеристики к ней и формирует URL транзакции.

	Архитектура взаимодействия бота и сервера проиллюстрирована на рисунке {\color{blue} \ref{fig.ganservice}}.
	\begin{figure}
		\centering
		\includegraphics[height=50mm]{fig/gan-service.png}
		\caption{Marketplace contract sell}
		\label{fig.ganservice}
	\end{figure}


\begin{remark}
	Создание нового NFT удовлетворяет следующему свойству: Пользователь при генерации NFT увидит саму картинку только подписания транзакции.
\end{remark}

\subsection{Устройство случайного получения NFT}
 Для того чтобы пользователь не видел картинку которую получит до подписания транзакции мы используем следующую схему:
  Формируем контракт в котором будут N сгенерированных NFT, которые хранятся в динамическом массиве, в этот массив добавляется (N + 1)'ый NFT, но при этом пользователю будет возвращаться случайный NFT из этого массива.
  Таким образом пользователь не сможет угадать, какая именно nft ему выпадет.
